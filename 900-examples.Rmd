---
output:
  pdf_document: default
  html_document: default
---


<!-- 
This file by Martin Monkman is licensed under a Creative Commons Attribution 4.0 International License. 
-->



```{r setup_ch900, include=FALSE, eval=TRUE}

source("package_load.R")

```


# Extended examples {#examples}


\index{PDF}
\index{Excel}


In this chapter:

* Extracting a data table from a PDF file

* Extracting data that is encoded as formatting in an Excel file


## Data in PDF file



## Excel formatting as data

\index{Excel}

In the "Importing data" chapter, we read the contents of one sheet in an Excel file published by the UK Office of National Statistics, drawn from the 2021 Census of England and Wales. The file has the population by local authorities (regions), and includes sheets with notes about the data, and data tables containing the population by sex and five-year age groups, along with population density and number of households.

Our focus is on sheet "P01", with population by sex. The first few rows of the data look like this:

[screenshot]

One thing to notice about this data is the "Area name" field is hierarchical, with a series of sub-totals. The value "England and Wales" contains the total population, which is the sum of England (row x) and Wales (row 360). 

England is then further subdivided into nine sub-national regions (coded as "E12" in first three characters of the "Area code" variable). These regions are then are divided into smaller units, but the description of those units varies. These are London Boroughs (E09), Unitary Authorities (E06), Counties (E10), Metropolitan Counties (E11).

The Counties are divided into Non-Metropolitan Districts (E07), and Metropolitan Counties are further subdivided into Metropolitan Districts (E08).

Wales is divided into Unitary Authorities (there is no intervening region), coded as "W06" in first three characters of the "Area code" variable.

^[The hierarchy of the administrative geographies of the UK can be found at the "England" and "Wales" links from this page: https://www.ons.gov.uk/methodology/geography/ukgeographies/administrativegeography]

^[You can download a map of these regions at ["Local Authority Districts, Counties and Unitary Authorities (April 2021) Map in United Kingdom"](https://geoportal.statistics.gov.uk/documents/ons::local-authority-districts-counties-and-unitary-authorities-april-2021-map-in-united-kingdom--1/about)] into 


### Approach 1 - use the Area code


### Approach 2 - use Excel's formatting


The leading space we see when we view the Excel file in its native software is not created by space characters, but through Excel's "indent" formatting. There is an R package that has functions that allow us to turn that formatting into information that we can work with. For this, we will be using the packages {tidyxl} [@R-tidyxl] and {unpivotr} [@R-unpivotr].


```{r, eval=FALSE}
library(tidyxl)
library(unpivotr)
```

In the code below, we create an object with the file path as a character string. This has the result of being less typing (and with a name like this, far less risk of a typo), and RStudio can also recognize the object for the autofill feature. The second line of code uses the function `xlsx_sheet_names()` to get the names of all of the sheets in the Excel file. In this case, we are interested in the data in "P01".

```{r}

uk_census_path <- "data/census2021firstresultsenglandwales1.xlsx"

xlsx_sheet_names(
  uk_census_path
  )

```


We already know that Excel files can contain a lot of information that is outside the data rectangle. Rather than ignore all that at the start, we will use the function `tidyxl::xlsx_cells()` to read the entire sheet, using the object with the file path and the `sheets = ` argument to specify what to read. Unlike `readxl::read_excel()`, we won't specify the sheet geometry. This will read the contents of the entire sheet, we will extract the data we want from the object "uk_census" created below. 


```{r}

uk_census <- xlsx_cells(
  uk_census_path,
  sheets = "P01"
  )

# take a quick look
dplyr::glimpse(uk_census)

```

The dataframe created by the `xlsx_cells()` function is nothing like the spreadsheet in the Excel file. Instead, every cell in Excel file is row, and details about that cell are captured. The cell location is captured in the variable "address", while there is also a separate variable for the row number and another for the column number. There is also the value we would see if we were to look at the file, in the variable "character". (If there is a formula in a cell, the function returns the result of the formula in the "character" variable, and the text of the formula in the "formula" variable.)

The "local_format_id" variable is created by {tidyxlr}, and helps us solve the problem of capturing the indentation. This variable contains a unique value for every different type of formatting that is used in the sheet. Below, we look at the first ten rows of the "uk_census" object, and we can see that the value "14" appears repeatedly in the variable "local_format_id".

```{r}
#select(uk_census_col02, row, col, data_type, character, numeric, local_format_id)
uk_census |> 
  slice_head(n = 10) |> 
  select(address, character, local_format_id)

```



The next thing we need to do is read the details of each of the formats stored in the Excel file—the format "14" has particular characteristics, including the number of indentations in the cell. 

For this, we use the {tidyxl} function `xlsx_formats()`. For this, we only need to specify the path to the file. "Excel defines only one of these dictionaries for the whole workbook, so that it records each combination of formats only once. Two cells that have the same formatting, but are in different sheets, will have the same format code, referring to the same entries in that dictionary." ^[Duncan Garmonsway, response to issue #84, {tidyxl} package repository, 2022-05-26. https://github.com/nacnudus/tidyxl/issues/84]

The code below reads the formats, and assigns it to a new object "formats".

```{r}

formats <- xlsx_formats(
  uk_census_path
)

```

[insert image]

When examining the "formats" object, we see that it contains two lists, one called "local" and the other "style". If we look inside "local", we see one called "alignment", and within that is "indent"—this is what we're looking for. We can extract that list-within-a-list, which contains all the indentation specifications of the different cell formats in the file, using the code below:


```{r}

indent <- formats$local$alignment$indent

```


Back to the object "uk_census". We are interested in the data starting in the eighth row, so we need to filter for that. 

For the functions to work, we need to have the column that defines the structure in the first position. To accomplish this, we will select it out using the "!=" operator.

The `behead_if()` function is designed to identify a level of headers in a pivot table, and make it part of the data. Similar to the {tidyr} function `pivot_longer()`, it creates a new variable for each row based on the headers. In the case of the UK Census data, the headers are differentiated by the number of indents in the formatting.




```{r}
uk_census |> 
  dplyr::filter((row >= 7)) |> 
  filter(col != 1) |> 
  behead_if(indent[local_format_id] == 0, 
            direction = "left-up", 
            name = "field0"
            ) |>
  select(address, row, col, content, field0) |> 
  dplyr::filter(row < 30)

```



```{r}
uk_census |> 
  dplyr::filter((row >= 7)) |> 
  filter(col != 1) |> 
  behead_if(indent[local_format_id] == 0, direction = "left-up", name = "field0") |> 
  behead_if(indent[local_format_id] == 1, direction = "left-up", name = "field1") |> 
  behead_if(indent[local_format_id] == 2, direction = "left-up", name = "field2") |> 
  behead_if(indent[local_format_id] == 3, direction = "left-up", name = "field3") |> 
  behead_if(indent[local_format_id] == 4, direction = "left-up", name = "field4") 

uk_census_behead <- uk_census |> 
  dplyr::filter((row >= 7)) |> 
  filter(col != 1) |> 
  behead_if(indent[local_format_id] == 0, direction = "left-up", name = "field0") |> 
  behead_if(indent[local_format_id] == 1, direction = "left-up", name = "field1") |> 
  behead_if(indent[local_format_id] == 2, direction = "left-up", name = "field2") |> 
  behead_if(indent[local_format_id] == 3, direction = "left-up", name = "field3") |> 
  behead_if(indent[local_format_id] == 4, direction = "left", name = "field4") 
#  behead(direction = "left", name = "field4") 


uk_census_behead |> 
  select(field0, field1, field2, field3, field4)

uk_census_behead |> 
#  behead_if(direction = "left-up", name = "field4") |> 
#  dplyr::filter(row < 30) |> 
  select(address, content, field0, field1, field2, field3, field4) |> 
  group_by(field4) |> 
  tally() |> 
  arrange(desc(n))
  
uk_census_behead |> 
  select(address, content, field0, field1, field2, field3, field4) |> 
  filter(field4 == "Sunderland") 
  
  
uk_census_behead |> 
  select(address, content, field0, field1, field2, field3, field4) |> 
  filter(field4 == "Wirral") 

```


Now assign column headers. In this case the structure is not particularly complex, but {tidyr} can also deal with nested hierarchy in the headers as well.

```{r}
# from the prevous chunk:

uk_census_behead <- uk_census |> 
  dplyr::filter((row >= 7)) |> 
  filter(col != 1) |> 
  behead_if(indent[local_format_id] == 0, direction = "left-up", name = "field0") |> 
  behead_if(indent[local_format_id] == 1, direction = "left-up", name = "field1") |> 
  behead_if(indent[local_format_id] == 2, direction = "left-up", name = "field2") |> 
  behead_if(indent[local_format_id] == 3, direction = "left-up", name = "field3") |> 
  behead(direction = "left", name = "field4") |> 
#  now strip (behead) the column names 
  behead(direction = "up", name = "gender") |> 
# add row sorting to preserve visual comparability  
  arrange(row)


```

Let's do some quick checks of the data:

```{r}

uk_census_behead |> 
  select(field0:field4, gender, numeric)

```

```{r}
uk_census_behead |> 
  select(field0:field4, gender, numeric) |> 
  slice_tail(n = 10)

```

A check of the tail of the data (above) reveals a problem with the structure of the Excel file, and how our {tidyr} and {unpivotr} work: Wales is not divided into 

```{r}



```



Next step: filter so we only have unique values

```{r}

uk_census_behead |> 
  filter(is.na(field1))
  
uk_census_behead |> 
  filter(is.na(field2))

uk_census_behead |> 
  filter(row == 360)

```





## Further reading

