---
output:
  pdf_document: default
  html_document: default
---


<!-- 
This file by Martin Monkman is licensed under a Creative Commons Attribution 4.0 International License. 
-->



```{r setup_ch700, include=FALSE}

# packages

source("package_load.R")

```


# Cleaning techniques {#cleaning}

placeholder for chapter 7


* Cleaning dates and strings

* Dealing with missing values

* Creating conditional and calculated variables

  - indicator variables [@Gelman_etal_2014, p.366] (also known as dummy variables [@Suits_1957] and "one hot" encoding)


## Dealing with missing values

\index{missing values}

Convert -999 etc to `NA`

Imputation methods

* apply average

* hot deck imputation


## Creating conditional and calculated variables

Recoding with `dplyr::case_when()`


### Indicator variables

Creating indicator variables \index{indicator variables}

> To include a categorical variable in a regression, a natural approach is to construct an 'indicator variable' for each category. This allows a separate effect for each level of the category, without assuming any ordering or other structure on the categories. [@Gelman_etal_2014, p.366]

* also known as dummy variables\index{dummy variables|see{indicator variables}} [@Suits_1957] and "one hot" encoding\index{one hot encoding|see{indicator variables}}

Examples of this approach abound. It can be a useful approach in forecasting methods; Hyndman and Athanasopoulos provide examples where public holidays and days of the week are set as dummy variables [@Hyndman_Athanasopoulos_2021, section 7.4 "Some useful predictors"]

It is aslo a common approach in social data analysis, where categorical variables are frequently used to code information. In the section on "Discrimination and collider bias" in [@Cunningham_mixtape, pp.106–110], the data are represented in the following way ^[Note: the data in this table is different from what appears in _Causal Inference: The Mixtape_, since the values in the data in that source are randomly generated.]:

```{r ch700_mixtape_data, echo=FALSE}
set.seed(111) # The opus number of Beethoven's last piano sonata, a work of transcendent beauty


# code directly from _Causal Mixtape_ https://mixtape.scunning.com/dag.html?panelset=r-code
# except it generates 10 cases, not 10000
tb <- tibble(
  female = ifelse(runif(10)>=0.5,1,0),
  ability = rnorm(10),
  discrimination = female,
  occupation = 1 + 2*ability + 0*female - 2*discrimination + rnorm(10),
  wage = 1 - 1*discrimination + 1*occupation + 2*ability + rnorm(10) 
)

head(tb)
```

In this data, the variable `female` is coded as numeric, so it can be used as part of the regression modeling. 

More commonly, though, this variable is more likely to be captured and saved in one called "gender" or "sex", and often as a character string. The source data table that was used to save the data in the above table might have originally looked like this:

```{r}

tb2 <- tb %>% 
  dplyr::rename(gender = female) %>% 
  mutate(gender = case_when(
    gender == 1 ~ "female",
    TRUE ~ "male"
  ))


tb2
```



### `{fastDummies}` 

Because this type of data transformation is common, the package {fastDummies} [@R-fastDummies] has been created, containing the function `dummy_cols()` (or `dummy_columns()` if you prefer extra typing) that creates indicator variables. 

> If you are using the _tidymodels_ pipeline, the {recipes} package [@R-recipes] contains the `step_dummy()` function, which accomplishes much the same result as `fastDummies::dummy_cols()`. The book _Tidy Modeling with R_ by Max Kuhn and Julia Silge [@Kuhn_Silge_2022] is recommended; the creation of indicator variables is covered in Chapter 8 "Feature Engineering with recipes".



```{r}

tb2 %>% 
  fastDummies::dummy_cols() 

```

The variable `gender` has now been mutated into two additional variables, `gender_female` and `gender_male`. The names of the new variables are a concatenation of the original variable name and value, separated by an underscore.

Where the value of `gender` is "female", the value of `gender_female` is assigned as 1, and where `gender` is "male", `gender_female` is 0. The opposite is true of `gender_male`.


Multicollinearity can occur in a multiple regression model where multiple indicator variables are included, since they are the opposite of one another. Accordingly, an important set of options in the `dummy_cols()` function revolve around removing all but one of the created variables. `remove_first_dummy = TRUE` does just that; in this case, the `gender_female()` variable does not appear in the final result, since the value "female" appears in the first observation (row).

{Note to self: this is not entirely clear, esp. the reference in the last sentence to the first observation.}

```{r}

tb2 %>% 
  fastDummies::dummy_cols(remove_first_dummy = TRUE) 

```

Note that the results of this argument can be controlled through the conversion of character variables to factors.

```{r}
# create new tb table with "gender" as factor
tb3 <- tb2 %>% 
  mutate(gender = as.factor(gender)) 

levels(tb3$gender)
```

Note that the default order is alphabetical, so "female" remains first. When the argument `remove_first_dummy = TRUE` is applied, we get the same result as before.

```{r}
  
tb3 %>% 
  fastDummies::dummy_cols(remove_first_dummy = TRUE) 


```

By using the `fct_relevel()` function from the {forcats}[@R-forcats] package, we can assign an arbitrary order.

```{r}
# reorder levels 

tb3$gender <- fct_relevel(tb3$gender, "male", "female")

levels(tb3$gender)
```

Rerunning the same code, the `gender_male` variable is dropped.

```{r}
  
tb3 %>% 
  fastDummies::dummy_cols(remove_first_dummy = TRUE) 


```


There is also an option `remove_most_frequent_dummy = TRUE`. In our discrimination data, there are more observations coded as "male", so the variable `gender_male` is not included.


```{r}

tb2 %>% 
  fastDummies::dummy_cols(remove_most_frequent_dummy = TRUE) 


```


Another argument in the function is `remove_selected_columns`. The default value is `FALSE`, but if the argument is set to `TRUE`, the source column is excluded from the output. 

```{r}

tb2 %>% 
  fastDummies::dummy_cols(remove_selected_columns = TRUE) 

```



Some important things to note about `dummy_cols()` 

* the function will create as many indicator variables as there are values in the character or factor variable

* the function will create indicator variables for all of the character and factor variables in the data, unless otherwise specified.

Let's look at how `dummy_cols()` behaves with two of the variables in {palmerpenguins}: \index{palmerpenguins}  

```{r ch700_dummy_penguins_1, echo=FALSE}

library(palmerpenguins)

set.seed(1729) #Ramanujan's taxicab number: 1^3 + 12^3 = 9^3 + 10^3

penguin_subset <- penguins %>% 
  slice_sample(n = 5) %>% 
  dplyr::select(species, island) %>% 
  arrange(species)

penguin_subset

```

```{r ch700_dummy_penguins_2}

penguin_subset %>%  
  fastDummies::dummy_cols()

```

First, you will notice that we started with two factor variables, `species` and `island`, we now have indicator variables for both.

And because there are three species of penguins and three islands, we have three indicator variables for both of the original variables.

In the instance where we have multiple character or factor variables in our source data, we can control which variables get the `dummy_cols()` treatment with the option `select_columns`. In the example below, the result provides us with an indicator variable for `species` but not `island`.

```{r 700_penguin_dummy}


penguin_subset %>% 
  fastDummies::dummy_cols(select_columns = "species")


```


Later: add dummy rows with `dummy_rows()`

### a tidyr::pivot_longer() solution

https://twitter.com/_TanHo/status/1415100126272577536?s=20&t=VsY7hHNn01lS17_eXvUvhA  

https://gist.github.com/tanho63/50d9b323e29165ad3e027bc3cf1c5926

https://tidyr.tidyverse.org/articles/pivot.html#multiple-observations-per-row


## Fill missing values

Frequently, our data will have missing values. There are a variety of solutions to dealing with missingness, from listwise deletion (removing all rows with missing values) to complex algorithms that apply methods to impute the best estimate of the missing value.


A common spreadsheet formatting practice that makes the tables human-readable but less analysis-ready is to have a sub-section heading, often in a separate column. In our example Excel file, the sheet "Report" contains the data we want in a wide format. The name individual institution is in the second column (in Excel nomanclature, "B"), and the region ("Economic Development Region") is in the first column. However, the name of the region only appears in the row above the institutions in that region. This makes for a nicely formatted table, but isn't very helpful if we are trying to calculate average tuition fees by region.^[The creators of the file have provided us with a tidy sheet named "Data", and deserve kudos for sharing the data in a variety of layouts. But please be aware that this is approach the exception, not the rule.]

Our first step is to read in the data. Note that the code uses the Excel naming convention to define the rectangular range to be read, and omits the title rows at the top and the notes at the bottom of the sheet.

```{r}

tuition_data <- readxl::read_excel(dpjr::dpjr_data("intl_tuition_fees_bc.xlsx"),
                                   sheet = "Report",
                                   range = "A5:L36")

head(tuition_data)

```

The contents of the file have been read correctly, but there are many "NA" values in the "Economic Development Region" variable. The `fill()` function, in the {tidyr} package [@R-tidyr] [\index{{tidyr}}], provides the solution to this. The function replaces a missing value with either the previous or the next value in a variable. In the example here, it will replace all of the "NA" values with the region name above, stopping when it comes to the next non-NA record.

```{r}

tuition_data <- tuition_data %>% 
  fill("Economic Development Region")

head(tuition_data)
```

The next step is to use the {tidyr} function `drop_na()` to omit any row that contains an NA value. In this case, we want to drop what were the header rows that contained just the region name in the first column, and no values in the other columns.

These two solutions yield the same result:

```{r}
drop_na(tuition_data)

tuition_data %>% 
  drop_na()

```

It's worth noting that the `drop_na()` function provides an argument where we can specify columns. This gives us the flexibility to drop some rows where there is an NA in a specific variable, while keeping other rows that have a value in that variable but not in other variables.



### Imputation of missing values

There is a great deal of literature on the topic of imputation.

[@doi:10.1080/00223891.2018.1530680]

{simputation}: https://cran.r-project.org/web/packages/simputation/vignettes/intro.html

https://github.com/markvanderloo/simputation



#### Time series imputation

A special case of imputation are time series. For R users, the package {imputeTS} [@R-imputeTS] offers multiple "imputation algorithm implementations along with plotting functions for time series missing data statistics"


## Creating labelled factors from numeric variables

If you are familiar with statistical software packages such as SPSS, SAS, or Stata you will be used to working with labelled variables. These are categorical variables, where there are a limited number of categories. 

In some cases, there might be one or more values assigned to categories we might want to designate as "missing"—a common example can be found in surveys, where respondents are given the option of answering "don't know" and "not applicable". While these responses might be interesting in and of themselves, in some contexts we will want to assign them as missing.

In other cases, numeric values are used to store the categorical responses. 

The Joint Canada/United States Survey of Health (JCUSH)\index{Joint Canada/United States Survey of Health (JCUSH)} file we saw in the section on importing fixed width files gives us a good example of where categories are stored as numerical variables. For example, the variable "SPJ1_TYP" is either a "1" for responses from the Canadian sample, and a "2" for the sample from the United States. 

We will use this file to create labelled factors from the numeric values in the variables we imported. Here's the code we used previously to read the file:

```{r jcush_txt_read_vars_2}

jcush <- readr::read_fwf(dpjr::dpjr_data("JCUSH.txt"), 
         fwf_cols(
           SAMPLEID = c(1, 12),
           SPJ1_TYP = c(13, 13), 
           GHJ1DHDI = c(32, 32),
           SDJ1GHED = c(502, 502)
           ),
         col_types = list(
           SAMPLEID = col_character()
         ))

head(jcush)
```


The values for these variables are as follows:


| Name | Variable | Code | Value |
| :--- | :---     | :---:  | :---:  |
| SAMPLEID | Household identifier | unique number | &nbsp; |
| SPJ1_TYP | Sample type [country] | 1 | Canada |
| &nbsp; | &nbsp; | 2 | United States |
| GHJ1DHDI | Health Description Index | 0 | Poor |
| &nbsp; | &nbsp; | 1 | Fair |
| &nbsp; | &nbsp; | 2 | Good |
| &nbsp; | &nbsp; | 3 | Very Good |
| &nbsp; | &nbsp; | 4 | Excellent |
| &nbsp; | &nbsp; | 9 | Not Stated |
| SDJ1GHED | Highest level of post-secondary education attained | 1 | Less than high school |
| &nbsp; | &nbsp; | 2 | High school degree or equivalent (GED) |
| &nbsp; | &nbsp; | 3 | Trades Cert, Voc. Sch./Comm.Col./CEGEP |
| &nbsp; | &nbsp; | 4 | Univ or Coll. Cert. incl. below Bach. |
| &nbsp; | &nbsp; | 9 | Not Stated |



The variable "GHJ1DHDI" has the respondent's self-assessment of their overall health. Here's a summary table of the responses:

```{r}
jcush %>% 
  group_by(GHJ1DHDI) %>% 
  tally()

```

But it would be much more helpful and efficient if we attach the value labels to the dataframe.

One strategy is to create a new factor variable, that uses the value description instead of the numeric representation. For this, we will use the `fct_recode()` function from the {forcats} package[@R-forcats].

```{r}
library(forcats)

jcush_forcats <- jcush %>%
  # 1st mutate a new factor variable with the original values
  mutate(health_desc_fct = as.factor(GHJ1DHDI)) %>%
  # 2nd recode the values
  mutate(
    health_desc_fct = fct_recode(
      health_desc_fct,
      "Poor" = "0",
      "Fair" = "1",
      "Good" = "2",
      "Very Good" = "3",
      "Excellent" = "4",
      NULL = "9"
    )
  )


```

The `levels()` function allows us to inspect the labels. Note that because we specified the original value of "9" as `NULL`, it does not appear in the list.

```{r}
levels(jcush_forcats$health_desc_fct)
```

When we tally the results by our new variable, the "GHJ1DHDI" records with the value 9 are shown as "NA".

```{r}
jcush_forcats %>% 
  group_by(GHJ1DHDI, health_desc_fct) %>% 
  tally()

```


{haven}[@R-haven] provides another option.

```{r}
library(haven)

jcush_haven <- jcush %>%
  mutate(health_desc_lab = labelled(
    GHJ1DHDI,
    c(
      "Poor" = 0,
      "Fair" = 1,
      "Good" = 2,
      "Very Good" = 3,
      "Excellent" = 4,
      "Not Stated" = 9
    )
  ))

```

Note that our new variable is a "S3: haven_labelled" class, and the `ls.str()` function shows it as "dbl+lbl":

```{r}
ls.str(jcush_haven)
```


The `levels()` function can be used to inspect the result of this mutate.

```{r}

head(jcush_haven$health_desc_lab)

```

```{r}

# note: `as_factor()` works; `as.factor()` does not
levels(as_factor(jcush_haven$health_desc_lab))             
                                   
levels(as.factor(jcush_haven$health_desc_lab))             

```


A third option is to use the functions within the {labelled}[@R-labelled] package. 

```{r}
jcush_labelled <- jcush %>%
  mutate(health_desc_lab = labelled(
    GHJ1DHDI,
    c(
      "Poor" = 0,
      "Fair" = 1,
      "Good" = 2,
      "Very Good" = 3,
      "Excellent" = 4,
      "Not Stated" = 9
    )
  ))

jcush_labelled
```


```{r}

head(jcush_labelled$health_desc_lab)

```

```{r}

# note: `as_factor()` works; `as.factor()` does not
levels(as_factor(jcush_labelled$health_desc_lab))             
                                   
levels(as.factor(jcush_labelled$health_desc_lab))             

```

This package also allows for a descriptive name of the variable to be appended with the `var_lab()` function.


### Base R: `model.matrix`

[@Friendly_Meyer_2016, p.240]



